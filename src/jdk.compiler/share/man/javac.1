.\" Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
.\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
.\"
.\" This code is free software; you can redistribute it and/or modify it
.\" under the terms of the GNU General Public License version 2 only, as
.\" published by the Free Software Foundation.
.\"
.\" This code is distributed in the hope that it will be useful, but WITHOUT
.\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
.\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
.\" version 2 for more details (a copy is included in the LICENSE file that
.\" accompanied this code).
.\"
.\" You should have received a copy of the GNU General Public License version
.\" 2 along with this work; if not, write to the Free Software Foundation,
.\" Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
.\"
.\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
.\" or visit www.oracle.com if you need additional information or have any
.\" questions.
.\"
.\" Automatically generated by Pandoc 2.3.1
.\"
.TH "JAVAC" "1" "2018" "JDK 13" "JDK Commands"
.hy
.SH NAME
.PP
javac \- read Java class and interface definitions and compile them into
bytecode and class files
.SH SYNOPSIS
.PP
\f[CB]javac\f[R] [\f[I]options\f[R]] [\f[I]sourcefiles\f[R]]
.TP
.B \f[I]options\f[R]
Command\-line options.
See \f[B]Overview of javac Options\f[R].
.RS
.RE
.TP
.B \f[I]sourcefiles\f[R]
One or more source files to be compiled (such as \f[CB]MyClass.java\f[R])
or processed for annotations (such as \f[CB]MyPackage.MyClass\f[R]).
.RS
.RE
.SH DESCRIPTION
.PP
The \f[CB]javac\f[R] command reads class and interface definitions,
written in the Java programming language, and compiles them into
bytecode class files.
The \f[CB]javac\f[R] command can also process annotations in Java source
files and classes.
.PP
A new launcher environment variable, \f[CB]JDK_JAVAC_OPTIONS\f[R], was
introduced in JDK 9 that prepended its content to the command line to
\f[CB]javac\f[R] .
See \f[B]Using JDK_JAVAC_OPTIONS Environment Variable\f[R].
.PP
There are two ways to pass source code file names to \f[CB]javac\f[R].
.IP \[bu] 2
For a small number of source files, you can list the file names on the
command line.
.IP \[bu] 2
For a large number of source files, you can use the
\f[CB]\@\f[R]\f[I]filename\f[R] option on the \f[CB]javac\f[R] command line
to include a file that lists the source file names.
See \f[B]Standard Options\f[R] for a description of the option and
\f[B]javac Command\-Line Argument Files\f[R] for a description of
\f[CB]javac\f[R] argument files.
.PP
Source code file names must have \f[CB]\&.java\f[R] suffixes, class file
names must have \f[CB]\&.class\f[R] suffixes, and both source and class
files must have root names that identify the class.
For example, a class called \f[CB]MyClass\f[R] would be written in a
source file called \f[CB]MyClass.java\f[R] and compiled into a bytecode
class file called \f[CB]MyClass.class\f[R].
.PP
Inner class definitions produce additional class files.
These class files have names that combine the inner and outer class
names, such as \f[CB]MyClass$MyInnerClass.class\f[R].
.PP
You should arrange the source files in a directory tree that reflects
their package tree.
For example:
.IP \[bu] 2
\f[B]Oracle Solaris, Linux, and OS X:\f[R] If all of your source files
are in \f[CB]/workspace\f[R], then put the source code for
\f[CB]com.mysoft.mypack.MyClass\f[R] in
\f[CB]/workspace/com/mysoft/mypack/MyClass.java\f[R].
.IP \[bu] 2
\f[B]Windows:\f[R] If all of your source files are in
\f[CB]\\workspace\f[R], then put the source code for
\f[CB]com.mysoft.mypack.MyClass\f[R] in
\f[CB]\\workspace\\com\\mysoft\\mypack\\MyClass.java\f[R].
.PP
By default, the compiler puts each class file in the same directory as
its source file.
You can specify a separate destination directory with the \f[CB]\-d\f[R]
option described in \f[B]Standard Options\f[R].
.SH PROGRAMMATIC INTERFACE
.PP
The \f[CB]javac\f[R] command supports the new Java Compiler API defined by
the classes and interfaces in the \f[CB]javax.tools\f[R] package.
.SH IMPLICITLY LOADED SOURCE FILES
.PP
To compile a set of source files, the compiler might need to implicitly
load additional source files.
See \f[B]Searching for Types\f[R].
Such files are currently not subject to annotation processing.
By default, the compiler gives a warning when annotation processing
occurs and any implicitly loaded source files are compiled.
The \f[CB]\-implicit\f[R] option provides a way to suppress the warning.
.SH USING JDK_JAVAC_OPTIONS ENVIRONMENT VARIABLE
.PP
The content of the \f[CB]JDK_JAVAC_OPTIONS\f[R] environment variable,
separated by white\-spaces ( ) or white\-space characters (\f[CB]\\n\f[R],
\f[CB]\\t\f[R], \f[CB]\\r\f[R], or \f[CB]\\f\f[R]) is prepended to the command
line arguments passed to \f[CB]javac\f[R] as a list of arguments.
.PP
The encoding requirement for the environment variable is the same as the
\f[CB]javac\f[R] command line on the system.
\f[CB]JDK_JAVAC_OPTIONS\f[R] environment variable content is treated in
the same manner as that specified in the command line.
.PP
Single quotes (\f[CB]\[aq]\f[R]) or double quotes (\f[CB]"\f[R]) can be used
to enclose arguments that\ contain whitespace characters.
All content between the open quote and the first matching close quote
are preserved by simply removing the pair of quotes.
In case a matching quote is not found, the launcher will abort with an
error message.
\f[CB]\@\f[R]\f[I]files\f[R] are supported as they are specified in the
command line.
However, as in \f[CB]\@\f[R]\f[I]files\f[R], use of a wildcard is not
supported.
.PP
\f[B]Examples of quoting arguments containing white spaces:\f[R]
.RS
.PP
\f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]\@"C:\\white\ spaces\\argfile"\[aq]\f[R]
.RE
.RS
.PP
\f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]"\@C:\\white\ spaces\\argfile"\[aq]\f[R]
.RE
.RS
.PP
\f[CB]export\ JDK_JAVAC_OPTIONS=\[aq]\@C:\\"white\ spaces"\\argfile\[aq]\f[R]
.RE
.SH OVERVIEW OF JAVAC OPTIONS
.PP
The compiler has sets of standard options, and cross\-compilation
options that are supported on the current development environment.
The compiler also has a set of nonstandard options that are specific to
the current virtual machine and compiler implementations but are subject
to change in the future.
The nonstandard options begin with \f[CB]\-X\f[R] .
The different sets of \f[CB]javac\f[R] options are described in the
following sections:
.IP \[bu] 2
\f[B]Standard Options\f[R]
.IP \[bu] 2
\f[B]Cross\-Compilation Options for javac\f[R]
.IP \[bu] 2
\f[B]Extra Options\f[R]
.SH STANDARD OPTIONS
.TP
.B \f[CB]\@\f[R]\f[I]filename\f[R]
Reads options and file names from a file.
To shorten or simplify the \f[CB]javac\f[R] command, you can specify one
or more files that contain arguments to the \f[CB]javac\f[R] command
(except \f[CB]\-J\f[R] options).
This lets you to create \f[CB]javac\f[R] commands of any length on any
operating system.
See \f[B]javac Command\-Line Argument Files\f[R].
.RS
.RE
.TP
.B \f[CB]\-A\f[R]\f[I]key\f[R][\f[CB]=\f[R]\f[I]value\f[R]]
Specifies options to pass to annotation processors.
These options aren\[aq]t interpreted by \f[CB]javac\f[R] directly, but are
made available for use by individual processors.
The \f[I]key\f[R] value should be one or more identifiers separated by a
dot (\f[CB]\&.\f[R]).
.RS
.RE
.TP
.B \f[CB]\-\-add\-modules\f[R] \f[I]module\f[R]\f[CB],\f[R]\f[I]module\f[R]
Specifies root modules to resolve in addition to the initial modules, or
all modules on the module path if \f[I]module\f[R] is
\f[CB]ALL\-MODULE\-PATH.\f[R]
.RS
.RE
.TP
.B \f[CB]\-\-boot\-class\-path\f[R] \f[I]path\f[R] or \f[CB]\-bootclasspath\f[R] \f[I]path\f[R]
Overrides the location of the bootstrap class files.
.RS
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-\-class\-path\f[R] \f[I]path\f[R], \f[CB]\-classpath\f[R] \f[I]path\f[R], or \f[CB]\-cp\f[R] \f[I]path\f[R]
Specifies where to find user class files and annotation processors.
This class path overrides the user class path in the \f[CB]CLASSPATH\f[R]
environment variable.
.RS
.IP \[bu] 2
If \f[CB]\-\-class\-path\f[R], \f[CB]\-classpath\f[R], or \f[CB]\-cp\f[R]
aren\[aq]t specified, then the user class path is the current directory.
.IP \[bu] 2
If the \f[CB]\-sourcepath\f[R] option isn\[aq]t specified, then the user
class path is also searched for source files.
.IP \[bu] 2
If the \f[CB]\-processorpath\f[R] option isn\[aq]t specified, then the
class path is also searched for annotation processors.
.RE
.TP
.B \f[CB]\-d\f[R] \f[I]directory\f[R]
Sets the destination directory for class files.
If a class is part of a package, then \f[CB]javac\f[R] puts the class file
in a subdirectory that reflects the package name and creates directories
as needed.
For example:
.RS
.IP \[bu] 2
\f[B]Oracle Solaris, Linux, and OS X:\f[R] If you specify
\f[CB]\-d\ /home/myclasses\f[R] and the class is called
\f[CB]com.mypackage.MyClass\f[R], then the class file is
\f[CB]/home/myclasses/com/mypackage/MyClass.class\f[R].
.IP \[bu] 2
\f[B]Windows:\f[R] If you specify \f[CB]\-d\ C:\\myclasses\f[R] and the
class is called \f[CB]com.mypackage.MyClass\f[R], then the class file is
\f[CB]C:\\myclasses\\com\\mypackage\\MyClass.class\f[R].
.PP
If the \f[CB]\-d\f[R] option isn\[aq]t specified, then \f[CB]javac\f[R] puts
each class file in the same directory as the source file from which it
was generated.
.PP
\f[B]Note:\f[R]
.PP
The directory specified by the \f[CB]\-d\f[R] option isn\[aq]t
automatically added to your user class path.
.RE
.TP
.B \f[CB]\-deprecation\f[R]
Shows a description of each use or override of a deprecated member or
class.
Without the \f[CB]\-deprecation\f[R] option, \f[CB]javac\f[R] shows a
summary of the source files that use or override deprecated members or
classes.
The \f[CB]\-deprecation\f[R] option is shorthand for
\f[CB]\-Xlint:deprecation\f[R].
.RS
.RE
.TP
.B \f[CB]\-\-enable\-preview\f[R]
Enables preview language features.
Used in conjunction with either \f[CB]\-source\f[R] or
\f[CB]\-\-release\f[R].
.RS
.RE
.TP
.B \f[CB]\-encoding\f[R] \f[I]encoding\f[R]
Specifies character encoding used by source files, such as EUC\-JP and
UTF\-8.
If the \f[CB]\-encoding\f[R] option isn\[aq]t specified, then the platform
default converter is used.
.RS
.RE
.TP
.B \f[CB]\-endorseddirs\f[R] \f[I]directories\f[R]
Overrides the location of the endorsed standards path.
.RS
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-extdirs\f[R] \f[I]directories\f[R]
Overrides the location of the installed extensions.
The \f[CB]directories\f[R] variable is a colon\-separated list of
directories.
Each JAR file in the specified directories is searched for class files.
All JAR files found become part of the class path.
.RS
.PP
If you are cross\-compiling, then this option specifies the directories
that contain the extension classes.
See \f[B]Cross\-Compilation Options for javac\f[R].
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-g\f[R]
Generates all debugging information, including local variables.
By default, only line number and source file information is generated.
.RS
.RE
.TP
.B \f[CB]\-g:\f[R][\f[CB]lines\f[R], \f[CB]vars\f[R], \f[CB]source\f[R]]
Generates only the kinds of debugging information specified by the
comma\-separated list of keywords.
Valid keywords are:
.RS
.TP
.B \f[CB]lines\f[R]
Line number debugging information.
.RS
.RE
.TP
.B \f[CB]vars\f[R]
Local variable debugging information.
.RS
.RE
.TP
.B \f[CB]source\f[R]
Source file debugging information.
.RS
.RE
.RE
.TP
.B \f[CB]\-g:none\f[R]
Doesn\[aq]t generate debugging information.
.RS
.RE
.TP
.B \f[CB]\-h\f[R] \f[I]directory\f[R]
Specfies where to place generated native header files.
.RS
.PP
When you specify this option, a native header file is generated for each
class that contains native methods or that has one or more constants
annotated with the \f[B]\f[BC]java.lang.annotation.Native\f[B]\f[R]
[https://docs.oracle.com/javase/10/docs/api/java/lang/annotation/Native.html]
annotation.
If the class is part of a package, then the compiler puts the native
header file in a subdirectory that reflects the package name and creates
directories as needed.
.RE
.TP
.B \f[CB]\-\-help\f[R], \f[CB]\-help\f[R] or \f[CB]\-?\f[R]
Prints a synopsis of the standard options.
.RS
.RE
.TP
.B \f[CB]\-\-help\-extra\f[R] or \f[CB]\-X\f[R]
Prints the help for extra options.
.RS
.RE
.TP
.B \f[CB]\-implicit:\f[R][\f[CB]none\f[R], \f[CB]class\f[R]]
Specifies whether or not to generate class files for implicitly
referenced files:
.RS
.IP \[bu] 2
\f[CB]\-implicit:class\f[R] \-\-\- Automatically generates class files.
.IP \[bu] 2
\f[CB]\-implicit:none\f[R] \-\-\- Suppresses class file generation.
.PP
If this option isn\[aq]t specified, then the default automatically
generates class files.
In this case, the compiler issues a warning if any class files are
generated when also doing annotation processing.
The warning isn\[aq]t issued when the \f[CB]\-implicit\f[R] option is
explicitly set.
See \f[B]Searching for Types\f[R].
.RE
.TP
.B \f[CB]\-J\f[R]\f[I]option\f[R]
Passes \f[I]option\f[R] to the runtime system, where \f[I]option\f[R] is
one of the Java options described on \f[B]java\f[R] command.
For example, \f[CB]\-J\-Xms48m\f[R] sets the startup memory to 48 MB.
.RS
.PP
\f[B]Note:\f[R]
.PP
The \f[CB]CLASSPATH\f[R] environment variable, \f[CB]\-classpath\f[R]
option, \f[CB]\-bootclasspath\f[R] option, and \f[CB]\-extdirs\f[R] option
don\[aq]t specify the classes used to run \f[CB]javac\f[R].
Trying to customize the compiler implementation with these options and
variables is risky and often doesn\[aq]t accomplish what you want.
If you must customize the complier implementation, then use the
\f[CB]\-J\f[R] option to pass options through to the underlying Java
launcher.
.RE
.TP
.B \f[CB]\-\-limit\-modules\f[R] \f[I]module\f[R]\f[CB],\f[R]\f[I]module\f[R]*
Limits the universe of observable modules.
.RS
.RE
.TP
.B \f[CB]\-\-module\f[R] \f[I]module\-name\f[R] or \f[CB]\-m\f[R] \f[I]module\-name\f[R]
Compiles only the specified module and checks time stamps.
.RS
.RE
.TP
.B \f[CB]\-\-module\-path\f[R] \f[I]path\f[R] or \f[CB]\-p\f[R] \f[I]path\f[R]
Specifies where to find application modules.
.RS
.RE
.TP
.B \f[CB]\-\-module\-source\-path\f[R] \f[I]module\-source\-path\f[R]
Specifies where to find input source files for multiple modules.
.RS
.RE
.TP
.B \f[CB]\-\-module\-version\f[R] \f[I]version\f[R]
Specifies the version of modules that are being compiled.
.RS
.RE
.TP
.B \f[CB]\-nowarn\f[R]
Disables warning messages.
This option operates the same as the \f[CB]\-Xlint:none\f[R] option.
.RS
.RE
.TP
.B \f[CB]\-parameters\f[R]
Generates metadata for reflection on method parameters.
Stores formal parameter names of constructors and methods in the
generated class file so that the method
\f[CB]java.lang.reflect.Executable.getParameters\f[R] from the Reflection
API can retrieve them.
.RS
.RE
.TP
.B \f[CB]\-proc:\f[R][\f[CB]none\f[R], \f[CB]only\f[R]]
Controls whether annotation processing and compilation are done.
\f[CB]\-proc:none\f[R] means that compilation takes place without
annotation processing.
\f[CB]\-proc:only\f[R] means that only annotation processing is done,
without any subsequent compilation.
.RS
.RE
.TP
.B \f[CB]\-processor\f[R] \f[I]class1\f[R][\f[CB],\f[R]\f[I]class2\f[R]\f[CB],\f[R]\f[I]class3\f[R]...]
Names of the annotation processors to run.
This bypasses the default discovery process.
.RS
.RE
.TP
.B \f[CB]\-\-processor\-module\-path\f[R] \f[I]path\f[R]
Specifies the module path used for finding annotation processors.
.RS
.RE
.TP
.B \f[CB]\-\-processor\-path\f[R] \f[I]path\f[R] or \f[CB]\-processorpath\f[R] \f[I]path\f[R]
Specifies where to find annotation processors.
If this option isn\[aq]t used, then the class path is searched for
processors.
.RS
.RE
.TP
.B \f[CB]\-profile\f[R] \f[I]profile\f[R]
Checks that the API used is available in the specified profile.
.RS
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-\-release\f[R] \f[I]release\f[R]
Compiles source code according to the rules of the Java programming
language for the specified Java SE release, generating class files
suitable for that release.
Additionally, compiles source code against the API of the specified Java
SE release and the API supported by the corresponding JDK release.
The supported values of \f[I]release\f[R] are the current Java SE release
and a limited number of previous releases.
The exact set of supported values is given in the command\-line help.
.RS
.PP
The API of a Java SE release consists of the \f[CB]java.*\f[R],
\f[CB]javax.*\f[R], and \f[CB]org.*\f[R] packages that are exported by Java
SE modules in the release.
.PP
The API supported by a JDK release consists of the \f[CB]com.*\f[R] and
\f[CB]jdk.*\f[R] packages that are exported by JDK modules in the release,
plus the \f[CB]javax.*\f[R] packages that are exported by standard, but
non\-Java SE, modules in the release.
.PP
\f[B]Note:\f[R]
.PP
The \f[CB]\-\-add\-exports\f[R] option cannot be used to enlarge the set
of packages exported by the Java SE and JDK API.
.RE
.TP
.B \f[CB]\-s\f[R] \f[I]directory\f[R]
Specifies the directory used to place the generated source files.
If a class is part of a package, then the compiler puts the source file
in a subdirectory that reflects the package name and creates directories
as needed.
For example:
.RS
.IP \[bu] 2
\f[B]Oracle Solaris, Linux, and OS X:\f[R] If you specify
\f[CB]\-s\ /home/mysrc\f[R] and the class is called
\f[CB]com.mypackage.MyClass\f[R], then the source file is put in
\f[CB]/home/mysrc/com/mypackage/MyClass.java\f[R].
.IP \[bu] 2
\f[B]Windows:\f[R] If you specify \f[CB]\-s\ C:\\mysrc\f[R] and the class
is called \f[CB]com.mypackage.MyClass\f[R], then the source file is put in
\f[CB]C:\\mysrc\\com\\mypackage\\MyClass.java\f[R].
.RE
.TP
.B \f[CB]\-\-source\f[R] \f[I]release\f[R] or \f[CB]\-source\f[R] \f[I]release\f[R]
Compiles source code according to the rules of the Java programming
language for the specified Java SE release.
The supported values of \f[I]release\f[R] are the current Java SE release
and a limited number of previous releases.
The exact set of supported values is given in the command\-line help.
.RS
.PP
If the option is not specified, the default is to compile source code
according to the rules of the Java programming language for the current
Java SE release.
.RE
.TP
.B \f[CB]\-\-source\-path\f[R] \f[I]path\f[R] or \f[CB]\-sourcepath\f[R] \f[I]path\f[R]
Specifies where to find input source files.
This is the source code path used to search for class or interface
definitions.
As with the user class path, source path entries are separated by colons
(\f[CB]:\f[R]) on Oracle Solaris and semicolons (\f[CB];\f[R]) on Windows.
They can be directories, JAR archives, or ZIP archives.
If packages are used, then the local path name within the directory or
archive must reflect the package name.
.RS
.PP
\f[B]Note:\f[R]
.PP
Classes found through the class path might be recompiled when their
source files are also found.
See \f[B]Searching for Types\f[R].
.RE
.TP
.B \f[CB]\-\-system\f[R] \f[I]jdk\f[R] | \f[CB]none\f[R]
Overrides the location of system modules.
.RS
.RE
.TP
.B \f[CB]\-\-target\f[R] \f[I]release\f[R] or \f[CB]\-target\f[R] \f[I]release\f[R]
Generates \f[CB]class\f[R] files suitable for the specified Java SE
release.
The supported values of \f[I]release\f[R] are the current Java SE release
and a limited number of previous releases.
The exact set of supported values is given in the command\-line help.
.RS
.PP
\f[B]Note:\f[R]
.PP
It is an error to specify a value for \f[I]release\f[R] that is lower
than the the release for which the source code is being compiled.
(See \f[CB]\-\-source\f[R]).
.RE
.TP
.B \f[CB]\-\-upgrade\-module\-path\f[R] \f[I]path\f[R]
Overrides the location of upgradeable modules.
.RS
.RE
.TP
.B \f[CB]\-verbose\f[R]
Outputs messages about what the compiler is doing.
Messages include information about each class loaded and each source
file compiled.
.RS
.RE
.TP
.B \f[CB]\-\-version\f[R] or \f[CB]\-version\f[R]
Prints version information.
.RS
.RE
.TP
.B \f[CB]\-Werror\f[R]
Terminates compilation when warnings occur.
.RS
.RE
.SH CROSS\-COMPILATION OPTIONS FOR JAVAC
.PP
By default, for releases prior to JDK 9, classes were compiled against
the bootstrap classes of the platform that shipped with
the\f[CB]javac\f[R] command.
But \f[CB]javac\f[R] also supports cross\-compiling, in which classes are
compiled against bootstrap classes of a different Java platform
implementation.
It\[aq]s important to use the \f[CB]\-bootclasspath\f[R] and
\f[CB]\-extdirs\f[R] options when cross\-compiling.
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.SH EXTRA OPTIONS
.TP
.B \f[CB]\-\-add\-exports\f[R] \f[I]module\f[R]\f[CB]/\f[R]\f[I]package\f[R]\f[CB]=\f[R]\f[I]other\-module\f[R](\f[CB],\f[R]\f[I]other\-module\f[R])*
Specifies a package to be considered as exported from its defining
module to additional modules or to all unnamed modules when the value of
\f[I]other\-module\f[R] is \f[CB]ALL\-UNNAMED\f[R].
.RS
.RE
.TP
.B \f[CB]\-\-add\-reads\f[R] \f[I]module\f[R]\f[CB]=\f[R]\f[I]other\-module\f[R](\f[CB],\f[R]\f[I]other\-module\f[R])*
Specifies additional modules to be considered as required by a given
module.
.RS
.RE
.TP
.B \f[CB]\-\-default\-module\-for\-created\-files\f[R] \f[I]module\-name\f[R]
Specifies the fallback target module for files created by annotation
processors, if none is specified or inferred.
.RS
.RE
.TP
.B \f[CB]\-Djava.endorsed.dirs=\f[R]\f[I]dirs\f[R]
Overrides the location of the endorsed standards path.
.RS
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-Djava.ext.dirs=\f[R]\f[I]dirs\f[R]
Overrides the location of installed extensions.
.RS
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-\-doclint\-format\f[R] [\f[CB]html4\f[R]|\f[CB]html5\f[R]]
Specifies the format for documentation comments.
.RS
.RE
.TP
.B \f[CB]\-\-patch\-module\f[R] \f[I]module\f[R]\f[CB]=\f[R]\f[I]file\f[R](\f[CB]:\f[R]\f[I]file\f[R])*
Overrides or augments a module with classes and resources in JAR files
or directories.
.RS
.RE
.TP
.B \f[CB]\-Xbootclasspath:\f[R]\f[I]path\f[R]
Overrides the location of the bootstrap class files.
.RS
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-Xbootclasspath/a:\f[R]\f[I]path\f[R]
Adds a suffix to the bootstrap class path.
.RS
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-Xbootclasspath/p:\f[R]\f[I]path\f[R]
Adds a prefix to the bootstrap class path.
.RS
.PP
\f[B]Note:\f[R]
.PP
This can only be used when compiling for versions prior to JDK 9.
As applicable, see the descriptions in\ \f[CB]\-\-release\f[R],
\f[CB]\-source\f[R], or \f[CB]\-target\f[R]\ for details.
.RE
.TP
.B \f[CB]\-Xdiags:\f[R][\f[CB]compact\f[R], \f[CB]verbose\f[R]]
Selects a diagnostic mode.
.RS
.RE
.TP
.B \f[CB]\-Xdoclint\f[R]
Enables recommended checks for problems in \f[CB]javadoc\f[R] comments
.RS
.RE
.TP
.B \f[CB]\-Xdoclint:\f[R](\f[CB]all\f[R]|\f[CB]none\f[R]|[\f[CB]\-\f[R]]\f[I]group\f[R])[\f[CB]/\f[R]\f[I]access\f[R]]
Enables or disables specific groups of checks,
.RS
.PP
\f[I]group\f[R] can have one of the following values:
.IP \[bu] 2
\f[CB]accessibility\f[R]
.IP \[bu] 2
\f[CB]html\f[R]
.IP \[bu] 2
\f[CB]missing\f[R]
.IP \[bu] 2
\f[CB]reference\f[R]
.IP \[bu] 2
\f[CB]syntax\f[R]
.PP
The variable \f[I]access\f[R] specifies the minimum visibility level of
classes and members that the \f[CB]\-Xdoclint\f[R] option checks.
It can have one of the following values (in order of most to least
visible):
.IP \[bu] 2
\f[CB]public\f[R]
.IP \[bu] 2
\f[CB]protected\f[R]
.IP \[bu] 2
\f[CB]package\f[R]
.IP \[bu] 2
\f[CB]private\f[R]
.PP
The default \f[I]access\f[R] level is \f[CB]private\f[R].
.PP
For more information about these groups of checks, see the
\f[CB]\-Xdoclint\f[R] option of the \f[CB]javadoc\f[R] command.
The \f[CB]\-Xdoclint\f[R] option is disabled by default in the
\f[CB]javac\f[R] command.
.PP
For example, the following option checks classes and members (with all
groups of checks) that have the access level of protected and higher
(which includes protected and public):
.RS
.PP
\f[CB]\-Xdoclint:all/protected\f[R]
.RE
.PP
The following option enables all groups of checks for all access levels,
except it won\[aq]t check for HTML errors for classes and members that
have the access level of package and higher (which includes package,
protected and public):
.RS
.PP
\f[CB]\-Xdoclint:all,\-html/package\f[R]
.RE
.RE
.TP
.B \f[CB]\-Xdoclint/package:\f[R][\f[CB]\-\f[R]]\f[I]packages\f[R](\f[CB],\f[R][\f[CB]\-\f[R]]\f[I]package\f[R])*
Enables or disables checks in specific packages.
Each \f[I]package\f[R] is either the qualified name of a package or a
package name prefix followed by \f[CB]\&.*\f[R], which expands to all
sub\-packages of the given package.
Each \f[I]package\f[R] can be prefixed with a hyphen (\f[CB]\-\f[R]) to
disable checks for a specified package or packages.
.RS
.RE
.TP
.B \f[CB]\-Xlint\f[R]
Enables all recommended warnings.
In this release, enabling all available warnings is recommended.
.RS
.RE
.TP
.B \f[CB]\-Xlint:\f[R][\f[CB]\-\f[R]]\f[I]key\f[R](\f[CB],\f[R][\f[CB]\-\f[R]]\f[I]key\f[R])*
Supplies warnings to enable or disable, separated by comma.
Precede a key by a hyphen (\f[CB]\-\f[R]) to disable the specified
warning.
.RS
.PP
Supported values for \f[I]key\f[R] are:
.IP \[bu] 2
\f[CB]all\f[R]: Enables all warnings.
.IP \[bu] 2
\f[CB]auxiliaryclass\f[R]: Warns about an auxiliary class that\[aq]s
hidden in a source file, and is used from other files.
.IP \[bu] 2
\f[CB]cast\f[R]: Warns about the use of unnecessary casts.
.IP \[bu] 2
\f[CB]classfile\f[R]: Warns about the issues related to classfile
contents.
.IP \[bu] 2
\f[CB]deprecation\f[R]: Warns about the use of deprecated items.
.IP \[bu] 2
\f[CB]dep\-ann\f[R]: Warns about the items marked as deprecated in
\f[CB]javadoc\f[R] but without the \f[CB]\@Deprecated\f[R] annotation.
.IP \[bu] 2
\f[CB]divzero\f[R]: Warns about the division by the constant integer 0.
.IP \[bu] 2
\f[CB]empty\f[R]: Warns about an empty statement after \f[CB]if\f[R].
.IP \[bu] 2
\f[CB]exports\f[R]: Warns about the issues regarding module exports.
.IP \[bu] 2
\f[CB]fallthrough\f[R]: Warns about the falling through from one case of a
switch statement to the next.
.IP \[bu] 2
\f[CB]finally\f[R]: Warns about \f[CB]finally\f[R] clauses that don\[aq]t
terminate normally.
.IP \[bu] 2
\f[CB]module\f[R]: Warns about the module system\-related issues.
.IP \[bu] 2
\f[CB]opens\f[R]: Warns about the issues related to module opens.
.IP \[bu] 2
\f[CB]options\f[R]: Warns about the issues relating to use of command line
options.
.IP \[bu] 2
\f[CB]overloads\f[R]: Warns about the issues related to method overloads.
.IP \[bu] 2
\f[CB]overrides\f[R]: Warns about the issues related to method overrides.
.IP \[bu] 2
\f[CB]path\f[R]: Warns about the invalid path elements on the command l
ine.
.IP \[bu] 2
\f[CB]processing\f[R]: Warns about the issues related to annotation
processing.
.IP \[bu] 2
\f[CB]rawtypes\f[R]: Warns about the use of raw types.
.IP \[bu] 2
\f[CB]removal\f[R]: Warns about the use of an API that has been marked for
removal.
.IP \[bu] 2
\f[CB]requires\-automatic\f[R]: Warns developers about the use of
automatic modules in requires clauses.
.IP \[bu] 2
\f[CB]requires\-transitive\-automatic\f[R]: Warns about automatic modules
in requires transitive.
.IP \[bu] 2
\f[CB]serial\f[R]: Warns about the serializable classes that don\[aq]t
provide a serial version ID.
Also warns about access to non\-public members from a serializable
element.
.IP \[bu] 2
\f[CB]static\f[R]: Warns about the accessing a static member using an
instance.
.IP \[bu] 2
\f[CB]try\f[R]: Warns about the issues relating to the use of try blocks (
that is, try\-with\-resources).
.IP \[bu] 2
\f[CB]unchecked\f[R]: Warns about the unchecked operations.
.IP \[bu] 2
\f[CB]varargs\f[R]: Warns about the potentially unsafe \f[CB]vararg\f[R]
methods.
.IP \[bu] 2
\f[CB]none\f[R]: Disables all warnings.
.PP
See \f[B]Examples of Using \-Xlint keys\f[R].
.RE
.TP
.B \f[CB]\-Xmaxerrs\f[R] \f[I]number\f[R]
Sets the maximum number of errors to print.
.RS
.RE
.TP
.B \f[CB]\-Xmaxwarns\f[R] \f[I]number\f[R]
Sets the maximum number of warnings to print.
.RS
.RE
.TP
.B \f[CB]\-Xpkginfo:\f[R][\f[CB]always\f[R], \f[CB]legacy\f[R], \f[CB]nonempty\f[R]]
Specifies when and how the \f[CB]javac\f[R] command generates
\f[CB]package\-info.class\f[R] files from \f[CB]package\-info.java\f[R]
files using one of the following options:
.RS
.TP
.B \f[CB]always\f[R]
Generates a \f[CB]package\-info.class\f[R] file for every
\f[CB]package\-info.java\f[R] file.
This option may be useful if you use a build system such as Ant, which
checks that each \f[CB]\&.java\f[R] file has a corresponding
\f[CB]\&.class\f[R] file.
.RS
.RE
.TP
.B \f[CB]legacy\f[R]
Generates a \f[CB]package\-info.class\f[R] file only if
\f[CB]package\-info.java\f[R] contains annotations.
This option doesn\[aq]t generate a \f[CB]package\-info.class\f[R] file if
\f[CB]package\-info.java\f[R] contains only comments.
.RS
.PP
\f[B]Note:\f[R]
.PP
A \f[CB]package\-info.class\f[R] file might be generated but be empty if
all the annotations in the \f[CB]package\-info.java\f[R] file have
\f[CB]RetentionPolicy.SOURCE\f[R].
.RE
.TP
.B \f[CB]nonempty\f[R]
Generates a \f[CB]package\-info.class\f[R] file only if
\f[CB]package\-info.java\f[R] contains annotations with
\f[CB]RetentionPolicy.CLASS\f[R] or \f[CB]RetentionPolicy.RUNTIME\f[R].
.RS
.RE
.RE
.TP
.B \f[CB]\-Xplugin:\f[R]\f[I]name\f[R] \f[I]args\f[R]
Specifies the name and optional arguments for a plug\-in to be run.
.RS
.RE
.TP
.B \f[CB]\-Xprefer:\f[R][\f[CB]source\f[R], \f[CB]newer\f[R]]
Specifies which file to read when both a source file and class file are
found for an implicitly compiled class using one of the following
options.
See \f[B]Searching for Types\f[R].
.RS
.IP \[bu] 2
\f[CB]\-Xprefer:newer\f[R]: Reads the newer of the source or class files
for a type (default).
.IP \[bu] 2
\f[CB]\-Xprefer:source\f[R] : Reads the source file.
Use \f[CB]\-Xprefer:source\f[R] when you want to be sure that any
annotation processors can access annotations declared with a retention
policy of \f[CB]SOURCE\f[R].
.RE
.TP
.B \f[CB]\-Xprint\f[R]
Prints a textual representation of specified types for debugging
purposes.
This doesn\[aq]t perform annotation processing or compilation.
The format of the output could change.
.RS
.RE
.TP
.B \f[CB]\-XprintProcessorInfo\f[R]
Prints information about which annotations a processor is asked to
process.
.RS
.RE
.TP
.B \f[CB]\-XprintRounds\f[R]
Prints information about initial and subsequent annotation processing
rounds.
.RS
.RE
.TP
.B \f[CB]\-Xstdout\f[R] \f[I]filename\f[R]
Sends compiler messages to the named file.
By default, compiler messages go to \f[CB]System.err\f[R].
.RS
.RE
.SH JAVAC COMMAND\-LINE ARGUMENT FILES
.PP
An argument file can include \f[CB]javac\f[R] options and source file
names in any combination.
The arguments within a file can be separated by spaces or new line
characters.
If a file name contains embedded spaces, then put the whole file name in
double quotation marks.
.PP
File names within an argument file are relative to the current
directory, not to the location of the argument file.
Wildcards (*) aren\[aq]t allowed in these lists (such as for specifying
\f[CB]*.java\f[R]).
Use of the at sign (\f[CB]\@\f[R]) to recursively interpret files
isn\[aq]t supported.
The \f[CB]\-J\f[R] options aren\[aq]t supported because they\[aq]re passed
to the launcher, which doesn\[aq]t support argument files.
.PP
When executing the \f[CB]javac\f[R] command, pass in the path and name of
each argument file with the at sign (\f[CB]\@\f[R]) leading character.
When the \f[CB]javac\f[R] command encounters an argument beginning with
the at sign (\f[CB]\@\f[R]), it expands the contents of that file into the
argument list.
.SH EXAMPLES OF USING JAVAC \@FILENAME
.TP
.B Single Argument File
You could use a single argument file named \f[CB]argfile\f[R] to hold all
\f[CB]javac\f[R] arguments:
.RS
.RS
.PP
\f[CB]javac\ \@argfile\f[R]
.RE
.PP
This argument file could contain the contents of both files shown in the
following \f[B]Two Argument Files\f[R] example.
.RE
.TP
.B Two Argument Files
You can create two argument files: one for the \f[CB]javac\f[R] options
and the other for the source file names.
Note that the following lists have no line\-continuation characters.
.RS
.PP
Create a file named \f[CB]options\f[R] that contains the following:
.PP
\f[B]Oracle Solaris, Linux, and OS X:\f[R]
.IP
.nf
\f[CB]
\-d\ classes
\-g
\-sourcepath\ /java/pubs/ws/1.3/src/share/classes
\f[R]
.fi
.PP
\f[B]Windows:\f[R]
.IP
.nf
\f[CB]
\-d\ classes
\-g
\-sourcepath\ C:\\java\\pubs\\ws\\1.3\\src\\share\\classes
\f[R]
.fi
.PP
Create a file named \f[CB]classes\f[R] that contains the following:
.IP
.nf
\f[CB]
MyClass1.java
MyClass2.java
MyClass3.java
\f[R]
.fi
.PP
Then, run the \f[CB]javac\f[R] command as follows:
.RS
.PP
\f[CB]javac\ \@options\ \@classes\f[R]
.RE
.RE
.TP
.B Argument Files with Paths
The argument files can have paths, but any file names inside the files
are relative to the current working directory (not \f[CB]path1\f[R] or
\f[CB]path2\f[R]):
.RS
.RS
.PP
\f[CB]javac\ \@path1/options\ \@path2/classes\f[R]
.RE
.RE
.SH EXAMPLES OF USING \-XLINT KEYS
.TP
.B \f[CB]cast\f[R]
Warns about unnecessary and redundant casts, for example:
.RS
.RS
.PP
\f[CB]String\ s\ =\ (String)\ "Hello!"\f[R]
.RE
.RE
.TP
.B \f[CB]classfile\f[R]
Warns about issues related to class file contents.
.RS
.RE
.TP
.B \f[CB]deprecation\f[R]
Warns about the use of deprecated items.
For example:
.RS
.IP
.nf
\f[CB]
java.util.Date\ myDate\ =\ new\ java.util.Date();
int\ currentDay\ =\ myDate.getDay();
\f[R]
.fi
.PP
The method \f[CB]java.util.Date.getDay\f[R] has been deprecated since JDK
1.1.
.RE
.TP
.B \f[CB]dep\-ann\f[R]
Warns about items that are documented with the \f[CB]\@deprecated\f[R]
Javadoc comment, but don\[aq]t have the \f[CB]\@Deprecated\f[R]
annotation, for example:
.RS
.IP
.nf
\f[CB]
/**
\ \ *\ \@deprecated\ As\ of\ Java\ SE\ 7,\ replaced\ by\ {\@link\ #newMethod()}
\ \ */
public\ static\ void\ deprecatedMethod()\ {\ }
public\ static\ void\ newMethod()\ {\ }
\f[R]
.fi
.RE
.TP
.B \f[CB]divzero\f[R]
Warns about division by the constant integer 0, for example:
.RS
.RS
.PP
\f[CB]int\ divideByZero\ =\ 42\ /\ 0;\f[R]
.RE
.RE
.TP
.B \f[CB]empty\f[R]
Warns about empty statements after \f[CB]if\f[R]statements, for example:
.RS
.IP
.nf
\f[CB]
class\ E\ {
\ \ \ \ void\ m()\ {
\ \ \ \ \ \ \ \ \ if\ (true)\ ;
\ \ \ \ }
}
\f[R]
.fi
.RE
.TP
.B \f[CB]fallthrough\f[R]
Checks the switch blocks for fall\-through cases and provides a warning
message for any that are found.
Fall\-through cases are cases in a switch block, other than the last
case in the block, whose code doesn\[aq]t include a break statement,
allowing code execution to fall through from that case to the next case.
For example, the code following the case 1 label in this switch block
doesn\[aq]t end with a break statement:
.RS
.IP
.nf
\f[CB]
switch\ (x)\ {
case\ 1:
\ \ System.out.println("1");
\ \ //\ No\ break\ statement\ here.
case\ 2:
\ \ System.out.println("2");
}
\f[R]
.fi
.PP
If the \f[CB]\-Xlint:fallthrough\f[R] option was used when compiling this
code, then the compiler emits a warning about possible fall\-through
into case, with the line number of the case in question.
.RE
.TP
.B \f[CB]finally\f[R]
Warns about \f[CB]finally\f[R] clauses that can\[aq]t be completed
normally, for example:
.RS
.IP
.nf
\f[CB]
public\ static\ int\ m()\ {
\ \ try\ {
\ \ \ \ \ throw\ new\ NullPointerException();
\ \ }\ \ catch\ (NullPointerException();\ {
\ \ \ \ \ System.err.println("Caught\ NullPointerException.");
\ \ \ \ \ return\ 1;
\ \ \ }\ finally\ {
\ \ \ \ \ return\ 0;
\ \ \ }
\ \ }
\f[R]
.fi
.PP
The compiler generates a warning for the \f[CB]finally\f[R] block in this
example.
When the \f[CB]int\f[R] method is called, it returns a value of 0.
A \f[CB]finally\f[R] block executes when the \f[CB]try\f[R] block exits.
In this example, when control is transferred to the \f[CB]catch\f[R]
block, the \f[CB]int\f[R] method exits.
However, the \f[CB]finally\f[R] block must execute, so it\[aq]s executed,
even though control was transferred outside the method.
.RE
.TP
.B \f[CB]options\f[R]
Warns about issues that related to the use of command\-line options.
See \f[B]Cross\-Compilation Options for javac\f[R].
.RS
.RE
.TP
.B \f[CB]overrides\f[R]
Warns about issues related to method overrides.
For example, consider the following two classes:
.RS
.IP
.nf
\f[CB]
public\ class\ ClassWithVarargsMethod\ {
\ \ void\ varargsMethod(String...\ s)\ {\ }
}

public\ class\ ClassWithOverridingMethod\ extends\ ClassWithVarargsMethod\ {
\ \ \ \@Override
\ \ \ void\ varargsMethod(String[]\ s)\ {\ }
}
\f[R]
.fi
.PP
The compiler generates a warning similar to the following:.
.IP
.nf
\f[CB]
warning:\ [override]\ varargsMethod(String[])\ in\ ClassWithOverridingMethod
overrides\ varargsMethod(String...)\ in\ ClassWithVarargsMethod;\ overriding
method\ is\ missing\ \[aq]...\[aq]
\f[R]
.fi
.PP
When the compiler encounters a \f[CB]varargs\f[R] method, it translates
the \f[CB]varargs\f[R] formal parameter into an array.
In the method \f[CB]ClassWithVarargsMethod.varargsMethod\f[R], the
compiler translates the \f[CB]varargs\f[R] formal parameter
\f[CB]String...\ s\f[R] to the formal parameter \f[CB]String[]\ s\f[R], an
array that matches the formal parameter of the method
\f[CB]ClassWithOverridingMethod.varargsMethod\f[R].
Consequently, this example compiles.
.RE
.TP
.B \f[CB]path\f[R]
Warns about invalid path elements and nonexistent path directories on
the command line (with regard to the class path, the source path, and
other paths).
Such warnings can\[aq]t be suppressed with the
\f[CB]\@SuppressWarnings\f[R] annotation.
For example:
.RS
.IP \[bu] 2
\f[B]Oracle Solaris, Linux, and OS X:\f[R]
\f[CB]javac\ \-Xlint:path\ \-classpath\ /nonexistentpath\ Example.java\f[R]
.IP \[bu] 2
\f[B]Windows:\f[R]
\f[CB]javac\ \-Xlint:path\ \-classpath\ C:\\nonexistentpath\ Example.java\f[R]
.RE
.TP
.B \f[CB]processing\f[R]
Warns about issues related to annotation processing.
The compiler generates this warning when you have a class that has an
annotation, and you use an annotation processor that can\[aq]t handle
that type of exception.
For example, the following is a simple annotation processor:
.RS
.PP
\f[B]Source file AnnocProc.java\f[R]:
.IP
.nf
\f[CB]
import\ java.util.*;
import\ javax.annotation.processing.*;
import\ javax.lang.model.*;
import\ javaz.lang.model.element.*;

\@SupportedAnnotationTypes("NotAnno")
public\ class\ AnnoProc\ extends\ AbstractProcessor\ {
\ \ public\ boolean\ process(Set<?\ extends\ TypeElement>\ elems,\ RoundEnvironment\ renv){
\ \ \ \ \ return\ true;
\ \ }

\ \ public\ SourceVersion\ getSupportedSourceVersion()\ {
\ \ \ \ \ return\ SourceVersion.latest();
\ \ \ }
}
\f[R]
.fi
.PP
\f[B]Source file AnnosWithoutProcessors.java\f[R]:
.IP
.nf
\f[CB]
\@interface\ Anno\ {\ }

\@Anno
class\ AnnosWithoutProcessors\ {\ }
\f[R]
.fi
.PP
The following commands compile the annotation processor
\f[CB]AnnoProc\f[R], then run this annotation processor against the source
file \f[CB]AnnosWithoutProcessors.java\f[R]:
.IP
.nf
\f[CB]
javac\ AnnoProc.java
javac\ \-cp\ .\ \-Xlint:processing\ \-processor\ AnnoProc\ \-proc:only\ AnnosWithoutProcessors.java
\f[R]
.fi
.PP
When the compiler runs the annotation processor against the source file
\f[CB]AnnosWithoutProcessors.java\f[R], it generates the following
warning:
.IP
.nf
\f[CB]
warning:\ [processing]\ No\ processor\ claimed\ any\ of\ these\ annotations:\ Anno
\f[R]
.fi
.PP
To resolve this issue, you can rename the annotation defined and used in
the class \f[CB]AnnosWithoutProcessors\f[R] from \f[CB]Anno\f[R] to
\f[CB]NotAnno\f[R].
.RE
.TP
.B \f[CB]rawtypes\f[R]
Warns about unchecked operations on raw types.
The following statement generates a \f[CB]rawtypes\f[R] warning:
.RS
.RS
.PP
\f[CB]void\ countElements(List\ l)\ {\ ...\ }\f[R]
.RE
.PP
The following example doesn\[aq]t generate a \f[CB]rawtypes\f[R] warning:
.RS
.PP
\f[CB]void\ countElements(List<?>\ l)\ {\ ...\ }\f[R]
.RE
.PP
\f[CB]List\f[R] is a raw type.
However, \f[CB]List<?>\f[R] is an unbounded wildcard parameterized type.
Because \f[CB]List\f[R] is a parameterized interface, always specify its
type argument.
In this example, the \f[CB]List\f[R] formal argument is specified with an
unbounded wildcard (\f[CB]?\f[R]) as its formal type parameter, which
means that the \f[CB]countElements\f[R] method can accept any
instantiation of the \f[CB]List\f[R] interface.
.RE
.TP
.B \f[CB]serial\f[R]
Warns about missing \f[CB]serialVersionUID\f[R] definitions on
serializable classes.
For example:
.RS
.IP
.nf
\f[CB]
public\ class\ PersistentTime\ implements\ Serializable
{
\ \ private\ Date\ time;

\ \ \ public\ PersistentTime()\ {
\ \ \ \ \ time\ =\ Calendar.getInstance().getTime();
\ \ \ }

\ \ \ public\ Date\ getTime()\ {
\ \ \ \ \ return\ time;
\ \ \ }
}
\f[R]
.fi
.PP
The compiler generates the following warning:
.IP
.nf
\f[CB]
warning:\ [serial]\ serializable\ class\ PersistentTime\ has\ no\ definition\ of
serialVersionUID
\f[R]
.fi
.PP
If a serializable class doesn\[aq]t explicitly declare a field named
\f[CB]serialVersionUID\f[R], then the serialization runtime environment
calculates a default \f[CB]serialVersionUID\f[R] value for that class
based on various aspects of the class, as described in the Java Object
Serialization Specification.
However, it\[aq]s strongly recommended that all serializable classes
explicitly declare \f[CB]serialVersionUID\f[R] values because the default
process of computing \f[CB]serialVersionUID\f[R] values is highly
sensitive to class details that can vary depending on compiler
implementations.
As a result, this might cause an unexpected
\f[CB]InvalidClassExceptions\f[R] during deserialization.
To guarantee a consistent \f[CB]serialVersionUID\f[R] value across
different Java compiler implementations, a serializable class must
declare an explicit \f[CB]serialVersionUID\f[R] value.
.RE
.TP
.B \f[CB]static\f[R]
Warns about issues relating to the use of statics variables, for
example:
.RS
.IP
.nf
\f[CB]
class\ XLintStatic\ {
\ \ \ \ static\ void\ m1()\ {\ }
\ \ \ \ void\ m2()\ {\ this.m1();\ }
}
\f[R]
.fi
.PP
The compiler generates the following warning:
.IP
.nf
\f[CB]
warning:\ [static]\ static\ method\ should\ be\ qualified\ by\ type\ name,
XLintStatic,\ instead\ of\ by\ an\ expression
\f[R]
.fi
.PP
To resolve this issue, you can call the \f[CB]static\f[R] method
\f[CB]m1\f[R] as follows:
.RS
.PP
\f[CB]XLintStatic.m1();\f[R]
.RE
.PP
Alternately, you can remove the \f[CB]static\f[R] keyword from the
declaration of the method \f[CB]m1\f[R].
.RE
.TP
.B \f[CB]try\f[R]
Warns about issues relating to the use of \f[CB]try\f[R] blocks, including
try\-with\-resources statements.
For example, a warning is generated for the following statement because
the resource \f[CB]ac\f[R] declared in the \f[CB]try\f[R] block isn\[aq]t
used:
.RS
.IP
.nf
\f[CB]
try\ (\ AutoCloseable\ ac\ =\ getResource()\ )\ {\ \ \ \ //\ do\ nothing}
\f[R]
.fi
.RE
.TP
.B \f[CB]unchecked\f[R]
Gives more detail for unchecked conversion warnings that are mandated by
the Java Language Specification, for example:
.RS
.IP
.nf
\f[CB]
List\ l\ =\ new\ ArrayList<Number>();
List<String>\ ls\ =\ l;\ \ \ \ \ \ \ //\ unchecked\ warning
\f[R]
.fi
.PP
During type erasure, the types \f[CB]ArrayList<Number>\f[R] and
\f[CB]List<String>\f[R] become \f[CB]ArrayList\f[R] and \f[CB]List\f[R],
respectively.
.PP
The \f[CB]ls\f[R] command has the parameterized type
\f[CB]List<String>\f[R].
When the \f[CB]List\f[R] referenced by \f[CB]l\f[R] is assigned to
\f[CB]ls\f[R], the compiler generates an unchecked warning.
At compile time, the compiler and JVM can\[aq]t determine whether
\f[CB]l\f[R] refers to a \f[CB]List<String>\f[R] type.
In this case, \f[CB]l\f[R] doesn\[aq]t refer to a \f[CB]List<String>\f[R]
type.
As a result, heap pollution occurs.
.PP
A heap pollution situation occurs when the \f[CB]List\f[R] object
\f[CB]l\f[R], whose static type is \f[CB]List<Number>\f[R], is assigned to
another \f[CB]List\f[R] object, \f[CB]ls\f[R], that has a different static
type, \f[CB]List<String>\f[R].
However, the compiler still allows this assignment.
It must allow this assignment to preserve backward compatibility with
releases of Java SE that don\[aq]t support generics.
Because of type erasure, \f[CB]List<Number>\f[R] and \f[CB]List<String>\f[R]
both become \f[CB]List\f[R].
Consequently, the compiler allows the assignment of the object
\f[CB]l\f[R], which has a raw type of \f[CB]List\f[R], to the object
\f[CB]ls\f[R].
.RE
.TP
.B \f[CB]varargs\f[R]
Warns about unsafe use of variable arguments (\f[CB]varargs\f[R]) methods,
in particular, those that contain non\-reifiable arguments, for example:
.RS
.IP
.nf
\f[CB]
public\ class\ ArrayBuilder\ {
\ \ public\ static\ <T>\ void\ addToList\ (List<T>\ listArg,\ T...\ elements)\ {
\ \ \ \ for\ (T\ x\ :\ elements)\ {
\ \ \ \ \ \ listArg.add(x);
\ \ \ \ }
\ \ }
}
\f[R]
.fi
.PP
A non\-reifiable type is a type whose type information isn\[aq]t fully
available at runtime.
.PP
The compiler generates the following warning for the definition of the
method \f[CB]ArrayBuilder.addToList\f[R]:
.IP
.nf
\f[CB]
warning:\ [varargs]\ Possible\ heap\ pollution\ from\ parameterized\ vararg\ type\ T
\f[R]
.fi
.PP
When the compiler encounters a varargs method, it translates the
\f[CB]varargs\f[R] formal parameter into an array.
However, the Java programming language doesn\[aq]t permit the creation
of arrays of parameterized types.
In the method \f[CB]ArrayBuilder.addToList\f[R], the compiler translates
the \f[CB]varargs\f[R] formal parameter \f[CB]T...\f[R] elements to the
formal parameter \f[CB]T[]\f[R] elements, an array.
However, because of type erasure, the compiler converts the
\f[CB]varargs\f[R] formal parameter to \f[CB]Object[]\f[R] elements.
Consequently, there\[aq]s a possibility of heap pollution.
.RE
.SH EXAMPLE OF COMPILING BY PROVIDING COMMAND\-LINE ARGUMENTS
.PP
To compile as though providing command\-line arguments, use the
following syntax:
.RS
.PP
\f[CB]JavaCompiler\ javac\ =\ ToolProvider.getSystemJavaCompiler();\f[R]
.RE
.PP
The example writes diagnostics to the standard output stream and returns
the exit code that \f[CB]javac\f[R] command would give when called from
the command line.
.PP
You can use other methods in the \f[CB]javax.tools.JavaCompiler\f[R]
interface to handle diagnostics, control where files are read from and
written to, and more.
.SH OLD INTERFACE
.PP
\f[B]Note:\f[R]
.PP
This API is retained for backward compatibility only.
All new code should use the Java Compiler API.
.PP
The \f[CB]com.sun.tools.javac.Main\f[R] class provides two static methods
to call the compiler from a program:
.IP
.nf
\f[CB]
public\ static\ int\ compile(String[]\ args);
public\ static\ int\ compile(String[]\ args,\ PrintWriter\ out);
\f[R]
.fi
.PP
The \f[CB]args\f[R] parameter represents any of the command\-line
arguments that would typically be passed to the compiler.
.PP
The \f[CB]out\f[R] parameter indicates where the compiler diagnostic
output is directed.
.PP
The \f[CB]return\f[R] value is equivalent to the \f[CB]exit\f[R] value from
\f[CB]javac\f[R].
.PP
\f[B]Note:\f[R]
.PP
All other classes and methods found in a package with names that start
with \f[CB]com.sun.tools.javac\f[R] (subpackages of
\f[CB]com.sun.tools.javac\f[R]) are strictly internal and subject to
change at any time.
.SH EXAMPLE OF COMPILING MULTIPLE SOURCE FILES
.PP
This example compiles the \f[CB]Aloha.java\f[R], \f[CB]GutenTag.java\f[R],
\f[CB]Hello.java\f[R], and \f[CB]Hi.java\f[R] source files in the
\f[CB]greetings\f[R] package.
.PP
\f[B]Oracle Solaris, Linux, and OS X:\f[R]
.IP
.nf
\f[CB]
%\ javac\ greetings/*.java
%\ ls\ greetings
Aloha.class\ \ \ \ \ \ \ \ \ GutenTag.class\ \ \ \ \ \ Hello.class\ \ \ \ \ \ \ \ \ Hi.class
Aloha.java\ \ \ \ \ \ \ \ \ \ GutenTag.java\ \ \ \ \ \ \ Hello.java\ \ \ \ \ \ \ \ \ \ Hi.java
\f[R]
.fi
.PP
\f[B]Windows:\f[R]
.IP
.nf
\f[CB]
C:\\>javac\ greetings\\*.java
C:\\>dir\ greetings
Aloha.class\ \ \ \ \ \ \ \ \ GutenTag.class\ \ \ \ \ \ Hello.class\ \ \ \ \ \ \ \ \ Hi.class
Aloha.java\ \ \ \ \ \ \ \ \ \ GutenTag.java\ \ \ \ \ \ \ Hello.java\ \ \ \ \ \ \ \ \ \ Hi.java
\f[R]
.fi
.SH EXAMPLE OF SPECIFYING A USER CLASS PATH
.PP
After changing one of the source files in the previous example,
recompile it:
.PP
\f[B]Oracle Solaris, Linux, and OS X:\f[R]
.IP
.nf
\f[CB]
pwd
/examples
javac\ greetings/Hi.java
\f[R]
.fi
.PP
\f[B]Windows:\f[R]
.IP
.nf
\f[CB]
C:\\>cd
\\examples
C:\\>javac\ greetings\\Hi.java
\f[R]
.fi
.PP
Because \f[CB]greetings.Hi\f[R] refers to other classes in the
\f[CB]greetings\f[R] package, the compiler needs to find these other
classes.
The previous example works because the default user class path is the
directory that contains the package directory.
If you want to recompile this file without concern for which directory
you are in, then add the examples directory to the user class path by
setting \f[CB]CLASSPATH\f[R].
This example uses the \f[CB]\-classpath\f[R] option.
.PP
\f[B]Oracle Solaris, Linux, and OS X:\f[R]
.RS
.PP
\f[CB]javac\ \-classpath\ /examples\ /examples/greetings/Hi.java\f[R]
.RE
.PP
\f[B]Windows:\f[R]
.RS
.PP
\f[CB]C:\\>javac\ \-classpath\ \\examples\ \\examples\\greetings\\Hi.java\f[R]
.RE
.PP
If you change \f[CB]greetings.Hi\f[R] to use a banner utility, then that
utility also needs to be accessible through the user class path.
.PP
\f[B]Oracle Solaris, Linux, and OS X:\f[R]
.IP
.nf
\f[CB]
javac\ \-classpath\ /examples:/lib/Banners.jar\ \\
\ \ \ \ \ \ \ \ \ \ \ \ /examples/greetings/Hi.java
\f[R]
.fi
.PP
\f[B]Windows:\f[R]
.IP
.nf
\f[CB]
C:\\>javac\ \-classpath\ \\examples;\\lib\\Banners.jar\ ^
\ \ \ \ \ \ \ \ \ \ \ \ \\examples\\greetings\\Hi.java
\f[R]
.fi
.PP
To execute a class in the \f[CB]greetings\f[R] package, the program needs
access to the \f[CB]greetings\f[R] package, and to the classes that the
\f[CB]greetings\f[R] classes use.
.PP
\f[B]Oracle Solaris, Linux, and OS X:\f[R]
.RS
.PP
\f[CB]java\ \-classpath\ /examples:/lib/Banners.jar\ greetings.Hi\f[R]
.RE
.PP
\f[B]Windows:\f[R]
.RS
.PP
\f[CB]C:\\>java\ \-classpath\ \\examples;\\lib\\Banners.jar\ greetings.Hi\f[R]
.RE
.PP
The \f[CB]\-source\ 1.7\f[R] option specifies that release 1.7 (or 7) of
the Java programming language must be used to compile OldCode.java.
The \f[CB]\-target\ 1.7\f[R] option ensures that the generated class files
are compatible with JVM 1.7.
.SH ANNOTATION PROCESSING
.PP
The \f[CB]javac\f[R] command provides direct support for annotation
processing, superseding the need for the separate annotation processing
command, \f[CB]apt\f[R].
.PP
The API for annotation processors is defined in the
\f[CB]javax.annotation.processing\f[R] and \f[CB]javax.lang.model\f[R]
packages and subpackages.
.SS How Annotation Processing Works
.PP
Unless annotation processing is disabled with the \f[CB]\-proc:none\f[R]
option, the compiler searches for any annotation processors that are
available.
The search path can be specified with the \f[CB]\-processorpath\f[R]
option.
If no path is specified, then the user class path is used.
Processors are located by means of service provider\-configuration files
named \f[CB]META\-INF/services/javax.annotation.processing\f[R].
Processor on the search path.
Such files should contain the names of any annotation processors to be
used, listed one per line.
Alternatively, processors can be specified explicitly, using the
\f[CB]\-processor\f[R] option.
.PP
After scanning the source files and classes on the command line to
determine what annotations are present, the compiler queries the
processors to determine what annotations they process.
When a match is found, the processor is called.
A processor can claim the annotations it processes, in which case no
further attempt is made to find any processors for those annotations.
After all of the annotations are claimed, the compiler does not search
for additional processors.
.PP
If any processors generate new source files, then another round of
annotation processing occurs: Any newly generated source files are
scanned, and the annotations processed as before.
Any processors called on previous rounds are also called on all
subsequent rounds.
This continues until no new source files are generated.
.PP
After a round occurs where no new source files are generated, the
annotation processors are called one last time, to give them a chance to
complete any remaining work.
Finally, unless the \f[CB]\-proc:only\f[R] option is used, the compiler
compiles the original and all generated source files.
.SH SEARCHING FOR TYPES
.PP
To compile a source file, the compiler often needs information about a
type, but the type definition is not in the source files specified on
the command line.
.PP
The compiler needs type information for every class or interface used,
extended, or implemented in the source file.
This includes classes and interfaces not explicitly mentioned in the
source file, but that provide information through inheritance.
.PP
For example, when you create a subclass of \f[CB]java.awt.Window\f[R], you
are also using the ancestor classes of \f[CB]Window\f[R]:
\f[CB]java.awt.Container\f[R], \f[CB]java.awt.Component\f[R], and
\f[CB]java.lang.Object\f[R].
.PP
When the compiler needs type information, it searches for a source file
or class file that defines the type.
The compiler searches for class files first in the bootstrap and
extension classes, then in the user class path (which by default is the
current directory).
The user class path is defined by setting the \f[CB]CLASSPATH\f[R]
environment variable or by using the \f[CB]\-classpath\f[R] option.
.PP
If you set the \f[CB]\-sourcepath\f[R] option, then the compiler searches
the indicated path for source files.
Otherwise, the compiler searches the user class path for both class
files and source files.
.PP
You can specify different bootstrap or extension classes with the
\f[CB]\-bootclasspath\f[R] and the \f[CB]\-extdirs\f[R] options.
See \f[B]Cross\-Compilation Options for javac\f[R].
.PP
A successful type search may produce a class file, a source file, or
both.
If both are found, then you can use the \f[CB]\-Xprefer\f[R] option to
instruct the compiler which to use.
If \f[CB]newer\f[R] is specified, then the compiler uses the newer of the
two files.
If \f[CB]source\f[R] is specified, the compiler uses the source file.
The default is \f[CB]newer\f[R].
.PP
If a type search finds a source file for a required type, either by
itself, or as a result of the setting for the \f[CB]\-Xprefer\f[R] option,
then the compiler reads the source file to get the information it needs.
By default the compiler also compiles the source file.
You can use the \f[CB]\-implicit\f[R] option to specify the behavior.
If \f[CB]none\f[R] is specified, then no class files are generated for the
source file.
If \f[CB]class\f[R] is specified, then class files are generated for the
source file.
.PP
The compiler might not discover the need for some type information until
after annotation processing completes.
When the type information is found in a source file and no
\f[CB]\-implicit\f[R] option is specified, the compiler gives a warning
that the file is being compiled without being subject to annotation
processing.
To disable the warning, either specify the file on the command line (so
that it will be subject to annotation processing) or use the
\f[CB]\-implicit\f[R] option to specify whether or not class files should
be generated for such source files.
